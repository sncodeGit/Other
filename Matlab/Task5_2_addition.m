% Go to main() function
main();

function [] = main()
    % Посмотрим поведение систем в их линейном виде:
    % y'' + y = 0
    % y'' + v*y' + y = 0
    % Рассмотрим две разные ситуации:
    % 1) Движение маятника с начальной скоростью из положения "вертикально вниз"
    % 2) Движение маятника с нулевой начальной скоростью из положения "вертикально вверх"
    
    % Ситуация 1)
    
    global right_y right_z start_y start_z
    right_y = @(x,y,z) z;
    start_y = [0, 0.0];
    start_z = [0, 2.0];
    
    right_z = @(x,y,z) -0.01*z-y;
    res_v_1 = runge_kutta(150, 0.01);
    
    right_z = @(x,y,z) -y;
    res = runge_kutta(20, 0.01);
    
    plot(res(1, :), res(3, :), 'g');
    title("1 линейная (угол), скорость 2, угол 0");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res(1, :), res(2, :), 'r');
    title("1 линейная (скорость), скорость 2, угол 0");
    xlabel("Время");
    ylabel("Скорость");
    figure;
    
    plot(res_v_1(1, :), res_v_1(3, :), 'g');
    title("2 линейная (угол), v = 0.01, скорость 2, угол 0");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res_v_1(1, :), res_v_1(2, :), 'r');
    title("2 линейная (скорость), v = 0.01, скорость 2, угол 0");
    xlabel("Время");
    ylabel("Скорость");
    figure;
    
    % Ситуация 2)
    
    right_y = @(x,y,z) z;
    start_y = [0, pi];
    start_z = [0, 0.0];
    
    right_z = @(x,y,z) -0.01*z-y;
    res_v_1 = runge_kutta(150, 0.01);
    
    right_z = @(x,y,z) -y;
    res = runge_kutta(20, 0.01);
    
    plot(res(1, :), res(3, :), 'g');
    title("1 линейная (угол), скорость 0, угол pi");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res(1, :), res(2, :), 'r');
    title("1 линейная (скорость), скорость 0, угол pi");
    xlabel("Время");
    ylabel("Скорость");
    figure;
    
    plot(res_v_1(1, :), res_v_1(3, :), 'g');
    title("2 линейная (угол), v = 0.01, скорость 0, угол pi");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res_v_1(1, :), res_v_1(2, :), 'r');
    title("2 линейная (скорость), v = 0.01, скорость 0, угол pi");
    xlabel("Время");
    ylabel("Скорость");
    figure;

    % Посмотрим повеление второй системы в её нелинейном виде:
    % y'' + y = 0
    % y'' + v*y' + sin(y) = 0
    % Рассмотрим две разные ситуации:
    % 1) Движение маятника с начальной скоростью из положения "вертикально вниз"
    % 2) Движение маятника с нулевой начальной скоростью из положения "вертикально вверх"
    
    % Ситуация 1)
    
    global right_y right_z start_y start_z
    right_y = @(x,y,z) z;
    start_y = [0, 0.0];
    start_z = [0, 2.0];
    
    right_z = @(x,y,z) -0.01*z-sin(y);
    res_v_1 = runge_kutta(150, 0.01);
    
    right_z = @(x,y,z) -y;
    res = runge_kutta(20, 0.01);
    
    plot(res(1, :), res(3, :), 'g');
    title("1 нелинейная (угол), скорость 2, угол 0");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res(1, :), res(2, :), 'r');
    title("1 нелинейная (скорость), скорость 2, угол 0");
    xlabel("Время");
    ylabel("Скорость");
    figure;
    
    plot(res_v_1(1, :), res_v_1(3, :), 'g');
    title("2 нелинейная (угол), v = 0.01, скорость 2, угол 0");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res_v_1(1, :), res_v_1(2, :), 'r');
    title("2 нелинейная (скорость), v = 0.01, скорость 2, угол 0");
    xlabel("Время");
    ylabel("Скорость");
    figure;

    % Ситуация 2)
    
    global right_y right_z start_y start_z
    right_y = @(x,y,z) z;
    start_y = [0, pi];
    start_z = [0, 0.0];
    
    right_z = @(x,y,z) -0.01*z-sin(y);
    res_v_1 = runge_kutta(800, 0.01);
    
    right_z = @(x,y,z) -y;
    res = runge_kutta(20, 0.01);
    
    plot(res(1, :), res(3, :), 'g');
    title("1 нелинейная (угол), скорость 0, угол pi");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res(1, :), res(2, :), 'r');
    title("1 нелинейная (скорость), скорость 0, угол pi");
    xlabel("Время");
    ylabel("Скорость");
    figure;
    
    plot(res_v_1(1, :), res_v_1(3, :), 'g');
    title("2 нелинейная (угол), v = 0.01, скорость 0, угол pi");
    xlabel("Время");
    ylabel("Угол");
    figure;
    
    plot(res_v_1(1, :), res_v_1(2, :), 'r');
    title("2 нелинейная (скорость), v = 0.01, скорость 0, угол pi");
    xlabel("Время");
    ylabel("Скорость");
    
    % Как видно, во втором случае (угол = pi, начальная скорость = 0)
    % нелинейная модель 2 системы показывает результаты отличные от результатов
    % линейной модели 2 системы.
    % Линейная модель не учитывает особенность понятия угла с точки зрения
    % того, что угол должен находится в пределе [-Pi, Pi], а линейная
    % модель учитывает (за счёт использования синуса).
    % Это видно в случае 2). Здесь в рамках данной математической модели 
    % (насколько я понимаю) маятник не должен двигаться поскольку нет силы,
    % воздействующей на него в горизонтальном направлении.
    % Также при использовании линейной модели при угле больше Pi
    % (или меньше -Pi) скорость будет увеличиваться бесконтрольно 
    % (чем больше будет отклонение от Pi, тем больше будет скорость), в
    % отличии от нелинейной модели.
    % Важный момент заключается в том, что ненулевая скорость (y') связана
    % не с особенностью самой модели. Она связана с особенностью метода
    % Рунге-Кутты 4 порядка и вероятно может считаться допустимой
    % погрешностью самого метода. При использовании, к примеру, метода
    % Эйлера данной ситуации не возникло бы.
end

% Решение системы диффур методом Рунге-Кутты 4 порядка
% b - правая граница отрезка
% delta - шаг метода
function res = runge_kutta(b, delta)
    global right_y right_z start_y start_z
    
    z = start_z(2);
    y = start_y(2);
    
    X = start_z(1):delta:b;
    Z = z;
    Y = y;
    
    for x = (start_z(1)+delta):delta:b
        next_val = runge_kutta_step(x, y, z, delta);
        z = next_val(1);
        y = next_val(2);
        Z = [Z z];
        Y = [Y y];
    end
    
    res = [X; Z; Y];
end

% Реализация шага метода Рунге-Кутты 4 порядка
function next_val = runge_kutta_step(x, y, z, delta)
    global right_y right_z
    k1 = delta * right_y(x, y, z);
    l1 = delta * right_z(x, y, z);
    k2 = delta * right_y(x + delta/2.0, y + k1/2.0, z + l1/2.0);
    l2 = delta * right_z(x + delta/2.0, y + k1/2.0, z + l1/2.0);
    k3 = delta * right_y(x + delta/2.0, y + k2/2.0, z + l2/2.0);
    l3 = delta * right_z(x + delta/2.0, y + k2/2.0, z + l2/2.0);
    k4 = delta * right_y(x + delta, y + k3, z + l3);
    l4 = delta * right_z(x + delta, y + k3, z + l3);
    next_y = y + (k1 + 2*k2 + 2*k3 + k4) / 6.0;
    next_z = z + (l1 + 2*l2 + 2*l3 + l4) / 6.0;
    next_val = [next_z next_y];
end
